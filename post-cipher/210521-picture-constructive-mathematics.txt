===
@@there are three kinds of object in the world: algorithms, problems, and machines.@@ _
@@an algorithm can solve a problem,@@
@@a problem can be computed on a machine,@@
@@and a machine can simulate another machine.@@ '

@@here@@ ^^.%^^ @@is an intuitionistic machine, which can only compute decidable algorithm.@@ _
@@at any rate, we at least have@@ ^^.%^^ @@at our disposal.@@ _
@@put most stupidly, if we #have@@ ^^.%^^ @@,@@ @@then we #have@@ ^^.%^^ @@.@@ _
@@namely:@@ '

^^`Void`.:
   .% |0 .%^^ '

@@suppose <machine@@ ^^$G^^ @@can simulate machine@@ ^^$D^^ @@>.@@ _
@@if we #have@@ ^^$G^^ @@,@@ @@and have any problem@@ ^^.X^^ @@{which is &computed on @@ ^^$D^^ @@,@@ @@then we have a valid new computer stronger than@@ ^^.%^^ @@.@@ _
@@namely:@@ '

^^`Instantiation_machine`.:
   `if` $G |0 $D.,^^ '
^^`then` `has` $f .[$G., .X.: .D.].: .%.;^^ '

@@suppose <computer@@ ^^$G^^ @@can compute problem@@ ^^.X^^ @@>.@@ _
@@if we #have@@ ^^$G^^ @@,@@ @@and have any algorithm@@ ^^.x^^ @@{which $solves@@ ^^.X^^ @@,@@ @@then we have a valid new computer stronger than@@ ^^.%^^ @@.@@ _
@@namely:@@ '

^^`Instantiation_problem`.:
   `if` $G |0 .X.,^^ '
^^`then` `has` $f .[$G., .x.: .X.].: .%.;^^ '

@@rules@@ ++InstMachine++ @@and@@ ++InstProblem++ @@correspond to universal instantiation in classical logic.@@ '
===

===
@@suppose <we #have such a method, <that, with machine@@ ^^.G^^ @@,@@ @@and with any .x an implementation of@@ ^^.X^^ @@,@@ @@we can simulate machine@@ ^^$D^^ @@>>.@@ _
@@then, with@@ ^^.G^^ @@,@@ @@we #obtain a method, by which any@@ ^^.x^^ @@an solution of@@ ^^.X^^ @@gives rise to a way to simulate@@ ^^$D^^ @@.@@ _
@@namely:@@ '

^^`Deduction_machine`.:
   `if` $y .[$G., .x.: .X.] |0 $D.,^^ '
^^`then` `has` $f .[$G.] .= $q.,
   $q .[.x.: .X.] .= $D.;^^ '

@@suppose <we #have such a method, <that, with machine@@ ^^.G^^ @@,@@ @@and with any .x an implementation of@@ ^^.X^^ @@,@@ @@we can solve problem@@ ^^.Y^^ @@>>.@@ _
@@then, with@@ ^^.G^^ @@,@@ @@we #obtain a method, by which any@@ ^^.x^^ @@an solution of@@ ^^.X^^ @@gives rise to a way to solve@@ ^^.Y^^ @@.@@ _
@@namely:@@ '

^^`Deduction_problem`.:
   `if` $y .[$G., .x.: .X.] |0 .Y.: .%.,^^ '
^^`then` `has` $f .[$G.] .= $q.,
   $q .[.x.: .X.].: .Y.;^^ '

@@rules@@ ++DedMachine++ @@and@@ ++DedProblem++ @@correspond to the deduction theorem in classical logic.@@ '
===

~~~

===
@@‚ùß@@ %%May 21, 2021;%%
%%extended August 9, 2021%% '
===


<<<
(1) ÊòüËôüÊòØ‰∏ÄÂè∞Áõ¥Ë¶∫‰∏ªÁæ©ÁöÑË®àÁÆóÊ©üÔºåÂÆÉÂèØËÉΩÂè™ËÉΩË®àÁÆóÂèØÂÅúÊ©üÁöÑÂïèÈ°å„ÄÇÂ¶ÇÊûúÊ≤íÊúâÂÖ∂‰ªñÊ¢ù‰ª∂ÔºåÂâáËá≥Â∞ëÊúâÈÄôÂè∞Ë®àÁÆóÊ©ü„ÄÇ

(2) Ë®≠Ê©üÂô® Œì ËÉΩÊ®°Êì¨Ê©üÂô® Œî„ÄÇËã•ÊàëÂÄëÊìÅÊúâ ŒìÔºåÂâáÊàëÂÄëËÉΩÂÅáË®≠ x ÊòØ‰∏ÄÂÄã Œî ËÉΩËß£Ê±∫ÁöÑÂïèÈ°åÔºåÊääÂÆÉÂàóÂÖ•ÂÖ¨ÁêÜ„ÄÇ

(3) Ë®≠Ê©üÂô® Œì ËÉΩÊ®°Êì¨ÂïèÈ°å M„ÄÇËã•ÊàëÂÄëÊìÅÊúâ ŒìÔºåÂâáÊàëÂÄëËÉΩÂÅáË®≠ x ÊòØ‰∏ÄÂÄã M ÁöÑÂáΩÊï∏ÂØ¶ÁèæÔºåÊääÂÆÉÂàóÂÖ•ÂÖ¨ÁêÜ„ÄÇËã•Áî®ÈÇèËºØËß£ÈáãÔºå(2) (3) Áõ∏Áï∂Êñº universal instantiation„ÄÇ

(4) ÊÉ≥Ë≠âÊòéÈÄôÂÄãÂÆöÁêÜ: x ÊòØ‰∏ÄÂÄã M ÁöÑÂáΩÊï∏ÂØ¶ÁèæÔºå‰πüËÉΩÁî®Ê©üÂô® ŒìÔºåÂâáÂ∞±ËÉΩÊ®°Êì¨ Œî„ÄÇÂèØ‰ª•ÈÄôÊ®£Ë≠âÊòé: Ë®≠ÊàëÂÄëÁöÑÁ¢∫ÊúâÊºîÁÆóÊ©ü xÔºåÁÑ∂ÂæåÂú® Œì‰∏äÊ®°Êì¨‰∫Ü ŒîÁöÑÊâÄÊúâËÉΩÂäõ„ÄÇ

(5) ÊÉ≥Ë≠âÊòéÈÄôÂÄãÂÆöÁêÜ: x ÊòØ‰∏ÄÂÄã M1 ÁöÑÂáΩÊï∏ÂØ¶ÁèæÔºå‰πüËÉΩÁî®Ê©üÂô® ŒìÔºåÂâáÂ∞±ËÉΩËß£Ê±∫ÂïèÈ°å M2„ÄÇÂèØ‰ª•ÈÄôÊ®£Ë≠âÊòé: Ë®≠ÊàëÂÄëÁöÑÁ¢∫ÊúâÊºîÁÆóÊ©ü xÔºåÁÑ∂ÂæåÂØ¶Áèæ‰∫Ü M2„ÄÇËã•Áî®ÈÇèËºØËß£ÈáãÔºå(4) (5)Áõ∏Áï∂Êñº deduction theorem„ÄÇ

(6) Ê©üÂô® ŒìÁî±ÂæàÂ§ö built in functions ÁµÑÊàêÔºåÂú®Êüê‰∏ÄË°åË™™‰∫ÜÂáΩÊï∏ l ÁöÑÂÆöÁæ©„ÄÇÂâáËÉΩÂ∞á l ÂèñÂá∫ÔºåÈÅ©Áï∂ÂÆöÁæ©Â≠êÁ≥ªÁµ± Œì/l„ÄÇÊàëÊ≤íÊúâÂæà‰ªîÁ¥∞ÁúãÈÄôÈªûÔºå‰ΩÜÊàëÁåúÊáâË©≤‰∏çÊòØÂæàÈáçË¶Å„ÄÇËã•Áî®ÈÇèËºØËß£ÈáãÔºåÁõ∏Áï∂ÊñºË™øÂãïÂÅáË®≠È†ÜÂ∫èÊôÇË¶ÅÂ∞èÂøÉÊãòÊùüËÆäÊï∏‰æùÁÑ∂ÊãòÊùü„ÄÇ

(7) Ëã•Áî® M2 ÂÆöÁæ©‰∏ÄÂÄãÊñ∞ÂáΩÊï∏ÔºåÊúâËá™ËÆäÊï∏ xÔºåË¶ÅÂ∞èÂøÉÁ¥ÄÈåÑ M2 ÁöÑÈ°ûÂíåxÁöÑÈ°û„ÄÇÂáΩÊï∏ÂÉèÁöÑÈ°ûÂíåM2Áõ∏ÂêåÔºåËá™ËÆäÊï∏ÁöÑÈ°ûÂíåxÁõ∏Âêå„ÄÇ

(8)Ëã•ÂÖàË™øÁî®NÂÜçË™øÁî®MÔºåÂáΩÊï∏MNÁöÑÈ°ûÔºåÊòØÂæûNÁöÑËá™ËÆäÊï∏ÁöÑÈ°ûÔºåÂà∞MÁöÑÂÉèÁöÑÈ°ûÂæóÂà∞„ÄÇËã•Áî®ÈÇèËºØËß£ÈáãÔºåÁõ∏Áï∂Êñº modus ponens„ÄÇ(7) (üòé ÊàëÂÄëÂØ´Á®ãÂºèÁöÑÊôÇÂÄôÈÉΩÂú®ÂÅöÔºåÂ∞±ÊòØ‰Ω†Ë¶∫ÂæóÁöÑÈÇ£ÂÄãÊÑèÊÄùÔºåÂè™ÊòØÂπ≥Â∏∏Ê≤íÊÑüË¶∫ËÄåÂ∑≤„ÄÇ

210521
>>>