This note summarizes the steps to install Arch Linux.
I do not intend to explain everything, and the wording is as concise as possible.
Do tell me if you find anything no longer working now, or any link broken.

##enter the firmware interface##

download the Arch Linux ISO, and make a bootable USB.
on Windows, we may use Rufus.
on Mac, we have to format the USB first, and copy the ISO into it using ++dd++ utility.

plug in the bootable USB, then enter the firmware interface.
before the computer starts normally, there will be a notice like “Please press DEL or F2 to enter UEFI BIOS setting”.
do that immediately, and there will be a temporary ++zsh++ shell, with prompt ++root@archiso ~ #++ @@.@@
From now, a ++#++ sign indicates the shell prompt.

##Partition and formatting##

List the disk blocks: '

++# lsblk++ '

The largest block shall be your hard disk, which is likely called ++sda++ @@.@@
a smaller one is the bootable USB we are using,
and a still smaller one is the ROM.

To partition the hard disk, invoke the command line utility ++parted++.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># parted /dev/sda
++</pre></div></div>

Here, the prompt ++(parted)++ will be shown for clarity.
Create a partition table with the MSDOS (MBR) standard.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) mklabel msdos
++</pre></div></div>

Meanwhile, UEFI/GPT partition is a newer standard, which not every motherboard supports.
Partitioning commands for UEFI/GPT are similar and covered in references.

My computer currently used has 1TB,
and I will generously allocate 40GB for ++/++(the root directory except for the user’s home), 2GB for swap memory, and the rest for ++/home/++(the user’s home).
Nowadays computers often have a large RAM (mine has 4GB),
and 2GB of swap memory shall be more than enough.

Create partition for the root directory except for home.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) mkpart primary ext4 1MiB 40GiB
++</pre></div></div>

Set the boot flag to be true.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) set 1 boot on
++</pre></div></div>

Create the partition for swap memory.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) mkpart primary linux-swap 40GiB 42GiB
++</pre></div></div>

Finally create the partition for the home, making up the rest of the hard disk.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) mkpart primary ext4 42GiB 100%
++</pre></div></div>

In the steps above, if the requested partition cannot be made precisely as such,
an alternative suggestion will be prompted.
You might also be asked again of the point of start and end, and of the file system.
I just apply default for everything.
You may also be warned that ++The resulting partition is not properly aligned for best performance.++ which we may ignore.

Print a summary of each partition to double check.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) print
++</pre></div></div>

My report has that ++sda1++ is the root directory except home, ++sda2++ the swap memory, ++sda3++ the root’s home.
Quit if everything looks fine.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parted) quit
++</pre></div></div>

Format partitions intended for root directory.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mkfs.ext4 /dev/sda1
++</pre></div></div>

Mount the root directory.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mount /dev/sda1 /mnt
++</pre></div></div>

To mount the home, create the directory, then mount it.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mkdir /mnt/home
# mount /dev/sda3 /mnt/home
++</pre></div></div>

<h1 id="installation-of-system-files">Installation of system files##

Now the internet connection is required,
since we will download packages.
It is best that you have ethernet automatically connected.
Otherwise, you have to set it in command line (which is not covered here).
Alternatively, you may use a Wifi (not covered here either).
We may test connection with (say)

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ping -c 3 www.google.com
++</pre></div></div>

Edit the list of mirrors,
so that closer servers are preferred.
(You may use ++nano++
if you are unfamiliar with ++vi++, and same hereafter.)

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># vi /etc/pacman.d/mirrorlist
++</pre></div></div>

Install the base packages, which will take quite a while, about twenty minutes in my case.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># pacstrap -i /mnt base base-devel
++</pre></div></div>

Generate the ++fstab++ file (which specifies information about mounted partitions),
and write it to the configuration file.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># genfstab -U /mnt > /mnt/etc/fstab
++</pre></div></div>

<h1 id="language-and-location">Language and location##

In completing the remaining tasks, temporarily take ++/mnt++ to be the root directory (the partition where Arch Linux will be installed).

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># arch-chroot /mnt
++</pre></div></div>

I shall choose American English to be the default for system display,
and further install Chinese input methods.
To do so, edit the languages to be enabled.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># vi /etc/locale.gen
++</pre></div></div>

I have to uncomment (delete the ++#++) before the line ++en_US.UTF-8 UTF-8++ and ++zh_TW.UTF-8 UTF-8++.
Then, ++locale-gen++ generates necessary information for all languages enabled,
while ++locale.conf++ specifies system display.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># locale-gen
# echo "LANG=en_US.UTF-8" > /etc/locale.conf
# export LANG=en_US.UTF-8
++</pre></div></div>

FOr me, I have to install the input method framework Ibus (package ++ibus++) and the input method Rime (package ++ibus-rime++).
It supports several Chinese input methods.
To initiate it at startup, add these lines in ++~/.xinitrc++:

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export GTK_IM_MODULE=ibus
export XMODIFIERS=@im=ibus
export QT_IM_MODULE=ibus
ibus-daemon -drx
++</pre></div></div>

Select the time zone.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># tzselect
++</pre></div></div>

In my case this is ++4) Asia++, and ++43) Taiwan++.
Its very existence of this item is a reassurance!

Create a symlink from the shared directory to the system configuration directory.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ln -s /usr/share/zoneinfo/Asia/Taiwan > /etc/localtime
++</pre></div></div>

Set the hardware clock.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># hwclock --systohc --utc
++</pre></div></div>

<h1 id="setting-a-boot-manager">Setting a boot manager##

For MBR users, download a boot manager and an OS-detector, possibly for sake of dual boot.
They are provided by packages ++grub++ and ++os-prober++.

Set up the ++grub++ on the booted partition, and generate the configuration file.
Again, replace ++sda++ with your partition name.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># grub-install --recheck --force --target=i386-pc /dev/sda
# grub-mkconfig -o /boot/grub/grub.cfg
++</pre></div></div>

At this point, I encountered the error ++Failed to connect to lvmetad++.
The is due to the ++lvmetad++ service that improves performance of LVM, the Logical Volume Manager (which manages disk drives and other mass-storage devices).
I have to disable it by editing ++/etc/lvm/lvm.conf++,
and write ++use_lvmetad = 0++.

<h1 id="setting-a-host-name">Setting a host name##

Replace ++Host-Name++ with your host name.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "Host-Name" > /etc/hostname
++</pre></div></div>

Set the root’s password.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># passwd
++</pre></div></div>

We may now leave the ++chroot++-ed environment,
unmount the corresponding partition,
and schedule shutdown.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># exit
# umount -R /mnt
# shutdown
++</pre></div></div>

Unplug the USB,
restart,
and login as ++root++.

<h1 id="internet-connection">Internet connection##

Assuming a connection is fine, we set up DHCP (Dynamic Host Configuration Protocol) that requests an IP address in the present ethernet.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ip link
++</pre></div></div>

The first item in the output is, in my case,

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: lo:mtu 65536 qdisk noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
++</pre></div></div>

Start the DHCP service now, and whenever the system boots.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># systemctl start dhcpcd@_______.service
# systemctl enable dhcpcd@_______.service
++</pre></div></div>

Replace the ++______++ with the name of wired device just seen above.
Mine is ++lo++.

<h1 id="creating-the-daily-users-account">Creating the daily user’s account##

Create a user account intended to be used on a daily basis.
Add the ID (mine is ++violapterin++) into the wheel group to get sudo privileges,
and sets its password.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># useradd -m -G wheel,users -s /bin/bash violapterin
# passwd violapterin
++</pre></div></div>

Install package ++sudo++ to get superuser privilege,
then edit the ++sudoers++ file.
Since this file is special, we have to specify the editor.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># EDITOR=vi visudo
++</pre></div></div>

Uncomment this line (by deleting the beginning ++#++).

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%wheel ALL=(ALL) ALL
++</pre></div></div>

<h1 id="basic-packages">Basic packages##

Make stable repositories available to package manager ++pacman++, by opening ++/etc/pacman.conf++, and uncommenting these lines:

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[multilib]
Include = /etc/pacman.d/mirrorlist
++</pre></div></div>

Update ++pacman++,
and install all refreshed packages.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># sudo pacman –Syu
++</pre></div></div>

Flags ++-Syu++ means, respectively, install packages, refresh database for packages, and look for existing outdated packages.

A
    <a href="https://wiki.archlinux.org/index.php/list_of_applications">comprehensive list of packages</a>,
is provided on Arch Linux Wiki’s
Besides the official repository that ++pacman++ uses, there is another Arch User Repository (AUR) maintained by community.
We need the so-called pacman helpers to install AUR packages, including ++yay++, ++pakku++, ++pikaur++, and ++pacaur++.
The flag ++-S++ again means installation.

##Graphical interface##

it remains to set up a desktop environment.
we install the X-server ++xorg-server++ and ++xorg-server-utils++.
check which graphic card the current system is using:

# lspci -v

As my computer has an Intel GPU, I have to install ++xf86-video-intel++ @@.@@

I choose KDE to be my desktop,
and installed packages ++plasma++ and ++kde-applications++ which took nearly thirty minutes.

configure ++.xinitrc++ that calls KDE on startup.
First, log in as the daily user’s account, and write these:

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo "exec startkd>" > ~/.xinitrc
++</pre></div></div>

Here ++.xinitrc++ must be saved in the daily user’s home in order to be found and read.
Even so, KDE will only be started after ++startx++ command is run.
To start KDE immediately after logged in, install package ++xorg-xinit++.
Put these lines in ++~/.bashrc++ @@:@@ _ '

++if [ -z "$DISPLAY" ] && [ -n "$XDG_VTNR" ] && [ "$XDG_VTNR" -eq 1 ]; then++ '
++exec startx++ '
++fi++ '

This means that we start the X server, if the display variable is not a null, and if there is more than one terminal instance.

In the presence of a beautiful GUI, instead of the scary monochrome console, I am sure the readers will figure out the rest.

##Source##

Arch Linux Wiki, «Installation Guide» \\https://wiki.archlinux.org/title/Installation_guide\\
Arch Linux Wiki, «List of applications» \\https://wiki.archlinux.org/title/List_of_applications\\
Arch Linux Wiki, «Desktop environment» \\https://wiki.archlinux.org/title/desktop_environment\\