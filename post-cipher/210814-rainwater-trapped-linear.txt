===
@@you are &given a set@@ ^^#r^^ @@representing the elevation map of a linear array, consisting of bars with unit width, with size@@ ^^.N^^ @@.@@ _
@@compute how much water it can trap after raining.@@ '

@@constraints:@@ '

^^.1
   <0 .N
   <0 .3 .* [.4: .1.0:].;^^ '
^^.0
   <0 [: #r: .[.n.]]
   <0 [.5: .1.0:],
   `for` .n .= .1 ., /6 ., .N.;^^ '
===

===
@@for brevity, for two lists@@ ^^#u., #v^^ @@we say@@ ^^#v <1 #u^^ @@if@@ ^^[:#v: .[.n.]] <1 [:#v: .[.n.]]^^ @@for each@@ ^^.n^^ @@;@@
@@and we similarly #compare a scalar@@ ^^$a^^ @@with a list@@ ^^#v^^ @@.@@ _
@@also@@ ^^.<#u., #v.>^^ @@is a concatenated list, with@@ ^^#u., #v^^ @@understood to be flattened;@@
@@and we similarly #concatenate a scalar@@ ^^$a^^ @@to a list@@ ^^#v^^ @@.@@ _
@@we #say a list to be increasing, if its components are increasing with respect to the numbered order;@@
@@and we similarly #say a list to be decreasing.@@ '

@@suppose@@ ^^$y .[#v.]^^ @@$gives the amount of rainwater trapped.@@ _
@@let@@ ^^.M^^ @@be the water level;@@
@@then@@ ^^$y .[#v.]^^ @@may be found as@@ ^^$f .[.M., #v.]^^ @@,@@ @@by summing the water from the bar to the level in each grid.@@ _
@@but how to find@@ ^^.M^^ @@?@@ '

@@if@@ ^^#x .= .<#v., $a., #u.>^^ @@with@@ ^^.<#v., $a.>^^ @@increasing, then we may remove #u without affecting the result;@@
@@similar is the decreasing case:@@ '

^^`Left_high`.:
   `if` .<#v., $a.> `increasing`.,
   `then` $y .[.<#v., $a., #u.>.]
      .= $y .[.<$a., #u.>.].;^^ '

^^`Right_high`.:
   `if` .<$a., #u.> `decreasing`.,
   `then` $y .[.<#v., $a., #u.>.]
      .= $y .[.<#v., $a.>.].;^^ '

@@or if@@ ^^#x .= .<$a., #v., $a., #u.>^^ @@with@@ ^^$a >1 #v^^ @@,@@ @@then we may break@@ ^^.<$a., #v., $a.>^^ @@from@@ ^^.<$a., #u.>^^ @@,@@ @@and add the respective answers;@@
@@similar is the decreasing case:@@ '

^^`Left_low`.:
   `if` $a >1 #v.,
   `then` $y .[.<$a., #v., $a., #u.>.]
      .= $y .[.<$a., #v., $a.>.] .+ $y .[.<$a., #u.>.]
      .= $f .[$a., .<$a., #v., $a.>.] .+ $y .[.<$a., #u.>.].;^^ '

^^`Right_low`.:
   `if` $a >1 #u.,
   `then` $y .[.<#v., $a., #u., $a.>.]
      .= $y .[.<$a., #u., $a.>.] .+ $y .[.<#v., $a.>.]
      .= $f .[$a., .<$a., #u., $a.>.] .+ $y .[.<#v., $a.>.].;^^ '

@@we #begin by examining@@ ^^#x^^ @@from the left end.@@ _
@@cases@@ ++Left_high++ @@and@@ ++Left_low++ @@are mutually exclusive,@@
@@and the situation <that neighboring components are equal $doesn’t matter>.@@ _
@@but there is a remaining case, <that@@ ^^#x .= .<$a., #v.>^^ @@with@@ ^^$a >1 #v^^ @@>.@@ _
@@when this $happens, we #turn to the right end to examine cases@@ ++Right_high++ @@and@@ ++Right_low++ @@{which is analogous}.@@ '
===

===
@@a moment of thought $reveals <that the overall time complexity is@@ ^^@O .[.N.]^^ @@>.@@ _
@@suppose we are %examining@@ ^^#x .= .<#v., $a.>^^ @@from the left end;@@
@@when@@ ^^#v^^ @@is &removed in case@@ ++Left_high++ @@,@@ @@it $takes@@ ^^@O .['size' #v.]^^ @@.@@ _
@@or else when@@ ^^#x .= .<$a., #v.>^^ @@with@@ ^^$a >1 #v^^ @@,@@
@@it $takes@@ ^^@O .['size' #x.]^^ @@,@@
@@but@@ ++Right_high++ @@or@@ ++Right_low++ @@must happen;@@
@@component@@ ^^$a^^ @@won’t be examined again.@@ _
@@hence any component $has to be examined twice at most.@@ '

@@the validity of algorithm $appears obvious;@@
@@it would be able to write a proof by a generalized induction on the length of the list, according to the steps@@ ++Left_high++ @@,@@ ++Left_low++ @@,@@ ++Right_high++ @@,@@ @@and@@ ++Right_low++ @@displayed above.@@ '
===

///
++# 42. Trapping Rain Water [hard]++ '
++#! /usr/bin/env python3++ '
++import typing as TYPE++ '
'
++def main():++ '
++   rain = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]++ '
++   solution = Solution()++ '
++   number = solution.count_trap(rain)++ '
++   print("There are", number, "drops.")++ '
++   # 6++ '
'
++class Solution:++ '
'
++   def count_trap(self, rain: TYPE.List[int]) -> int:++ '
++      return self.count_left(rain, 0, len(rain) - 1)++ '
'
++   def count_left(self, rain: TYPE.List[int], start: int, stop: int) -> int:++ '
++      if (stop - start <= 1): return 0++ '
++      left = self.probe_left(rain, start)++ '
++      if (left >= len(rain)): return self.count_right(rain, start, stop)++ '
++      water_left = sum([max(0, rain[start] - value) for value in rain[start:left+1]])++ '
++      water_right = self.count_left(rain, left, stop)++ '
++      return water_left + water_right++ '
'
++   def count_right(self, rain: TYPE.List[int], start: int, stop: int) -> int:++ '
++      if (stop - start <= 1): return 0++ '
++      right = self.probe_right(rain, stop)++ '
++      if (right < 0): return self.count_left(rain, start, stop)++ '
++      water_right = sum([max(0, rain[stop] - value) for value in rain[right:stop+1]])++ '
++      water_left = self.count_right(rain, start, right)++ '
++      return water_left + water_right++ '
'
++   def probe_right(self, rain: TYPE.List[int], start: int) -> int:++ '
++      limit = rain[start]++ '
++      head = start - 1++ '
++      while (head >= 0):++ '
++         if (rain[head] >= limit): break++ '
++         head -= 1++ '
++      return head++ '
'
++   def probe_left(self, rain: TYPE.List[int], start: int) -> int:++ '
++      limit = rain[start]++ '
++      head = start + 1++ '
++      while head < len(rain):++ '
++         if (rain[head] >= limit): break++ '
++         head += 1++ '
++      return head++ '
'
++# # # # # # # # # # # # # # # #++ '
'
++main()++ '
///

~~~

===
@@❧@@ %%August 14, 2021%%
===
