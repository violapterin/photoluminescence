=== ##classifying Git actions## ===

===
@@here is a slowly growing summary of Git commands I find helpful, with short explanations to the dear reader.@@ _
@@again, I appreciate anyone to correct my misunderstandings, if any.@@ _

@@Git is a convoluted beast,@@ _
@@and I #try to group actions by their point of departure and arrival.@@ _
@@indeed, interactions #occur between the working tree, the local, and remote repo.@@ _
@@commands@@ ++add++ @@,@@ ++commit++ @@,@@ and ++push++ @@,@@ @@among others, transfer data from the local end to the remote end.@@ _
@@commands@@ ++clone++ @@,@@ ++fetch++ @@,@@ ++pull++ @@,@@ and ++reset++ @@,@@ @@among others, transfer data from the remote end to the local end.@@ _

@@by convention, commands meant to be run in a Bash shell is prefixed with a@@ ++$++ @@.@@@@ _
@@and terms enclosed in ++<>++ are not verbatim.@@ _
@@remember <that Git commands accept the working directory to be either the top directory ({which we assume}) or any of its subdirectory, except ++.git/++, the local repo itself>.@@ _
@@(There are workarounds, but I guess it is safer to follow it.)@@ _
===

===
@@Git man pages can be called by, say:@@ _

++$ git help fetch++ '

@@or equivalently:@@ _

++$ git fetch --help++ '
===

=== ##from the tree to the local: add## ===

===
@@with@@ ++add++ @@,@@ @@changes in the working tree are &added to the stash.@@ _
@@to stage everything— new, modified, and deleted files— in the working tree:@@ _

++$ git add .++ '
===

===
@@to view a list of all tracked files:@@ _

++$ git ls-tree -r <branch> --name-only++ '
===

===
@@before committing, it is helpful to see a summary of new changes, with:@@ _

++$ git status++ '
===

===
@@to show modification in the working tree not added to the index:@@ _

++$ git diff++ '

@@or you can compare the indexed files with the latest commit:@@ _

++$ git diff --staged++ '

@@instead, to compare a specific file in the working tree with the committed version of it:@@ _

++$ git diff <commit> <certain_file>++ '

@@there will be a new page {that summarizes the modification}.@@ _
@@navigation commands are identical to@@ ++less++ @@,@@ @@and similar to Vim.@@ _
@@hit@@ ++j++ @@ @@or ++e++ @@ @@to forward one line,@@ _
@@and@@ ++k++ @@ @@or ++y++ @@,@@ to backward one line.@@ _
@@hit@@ ++f++ @@ @@to forward one window,@@ _
@@and@@ ++b++ @@ @@to backward one window.@@ _
@@hit@@ ++d++ @@ @@to forward one-half window,@@ _
@@and@@ ++u++ @@ @@to backward one-half window.@@ _
@@hit@@ ++q++ @@ @@to quit.@@ _
===

=== ##from the tree to the local: commit## ===

===
@@to commit your present files from the stash to the local repo:@@ _

++$ git commit++ '

@@however, a commit message is strongly recommended:@@ _

++$ git commit -m "<Commit message>"++ '

@@a commit message should summarize the new work concisely, within 70 characters.@@ _
@@if you cannot do this, you should probably split your work into more than one commits.@@ _
@@to save space, it is the tradition to use verbs in base form are used, and no period in the end.@@ _

@@you can modify your commit message even after you commit, with@@ _

++$ git commit --amend++ '

@@an editor should open, showing the commit message and the status.@@ _
@@this file is saved as@@ ++.git/COMMIT_EDITMSG++ @@.@@@@ _
@@I find it useful to edit the commit message this way, because I don’t have to backslash- escape special characters.@@ _
@@we may also add more explanatory lines below, separated from the commit message with a blank line.@@ _
===

===
@@sometimes we add a tag to single out more significant commits, especially when a commit is released to the public.@@ _
@@to add a tag to the latest commit (even when you have modified the working tree after committing), use@@ _

++$ git tag -a "<tag_number>" -m "<Commit_message>"++ '

@@to simply list all tag names:@@ _

++$ git tag++ '

@@to see <what commit is being pointed to>:@@ _

++$ git rev-list -1 "<tag_number>"++ '

@@a ++git push++ @@ @@don't automatically push a tag, but you have to do:@@ _

++$ git push origin "<tag_number>"++ '
===

===
@@the commit log $lists commit hashes, authors, time stamps, and commit messages.@@ _
@@to view the commit log:@@ _

++$ git log++ '

@@to make the log concise and informative:@@ _

++$ git log --all --decorate --oneline --graph++ '

@@pointer ++HEAD++ @@ @@refers to the current commit.@@ _
@@to retrieve its ancestors, two operators could be used.@@ _
@@pointer ++HEAD~2++ @@ @@refers to the eldest parent of the parent of the head.@@ _
@@pointer ++HEAD^3++ @@ @@means its third- to- last eldest parent of the head, and so on.@@ _
@@the two operators may be composed, for instance as ++HEAD^3~2++ @@.@@@@ _

=== ##from the local repo to the remote repo: push## ===

@@to push all consistent commits from the local repo to the remote repo:@@ _

++$ git push origin <branch_name>++ '

@@if option@@ ++-u++ @@or@@ ++--set-upstream++ @@is added,@@ @@we set up a tracking reference so <that we can type only@@ ++git push++ @@or@@ ++git pull++ @@and so on>.@@ _

@@if you have inconsistent commits, so Git $refuses to push, you may try the flag ++-f++ or ++--force++:@@ _
@@this forces every local commit to overwrite its remote counterpart,@@ _
@@and it may cause the remote repo to lose data.@@ _
@@think twice before using it!@@ _

=== ##from the remote to the local : clone, fetch, pull## ===

===
@@to clone everything from the remote repo into a new subdirectory of the current working directory (where the repo for the blog is taken for instance):@@ _

++$ git clone git@github.com:violapterinblog/violapterinblog.github.io.git++ '
===

===
@@fetching $creates a local copy of a remote branch in the local repo only, not affecting the working tree nor the head.@@ _
@@to fetch everything from the remote repo to the working tree:@@ _

++$ git fetch origin <branch_name>++ '
===

===
@@meanwhile, pulling not only $fetches all remote branches as said, but also $merges all conflicts into the specified branch.@@ _
@@to pull from origin to a branch:@@ _

++$ git pull origin <branch_name>++ '

@@it is more straightforward, I #think, to fetch and merge explicitly, than just to pull.@@ _
===

=== ##from the local to the tree: reset, revert## ===

===
you may reset the working tree to a previous state.

++$ git reset HEAD~2++ '

flag ++--soft++ rewrites changes not committed, leaving staged changes.
flag ++--mixed++ rewrites changes not committed or unstaged, leaving changes in the working tree.
flag ++--hard++ rewrites changes not committed or unstaged and the working tree.
===

===
meanwhile, to revert to previous commit,

++$ git revert <commit_pointer>++ '

this $restores the working tree to that commit,
but it $creates a new commit, not rewriting the history.
===

===
sometimes you #want to rewrite the history, to combine several commits as one.
to combine the last 5 commits as one:

++$ git reset --hard HEAD~5++ '
++$ git merge --squash HEAD@{1}++ '

the first command resets the head to the commit just before the last 5 commits,
and the second command combines these <N> commits.
Here, `HEAD@{1}` is the position of the head just before the previous command.
afterwards, commit.

or more simply, to do the same:

++$ git reset --soft HEAD~5++ '

afterwards, commit.
===

~~~

=== ##references## ===

@@Git,@@ @@Documentation@@ \\https://git-scm.com/documentation\\

@@❉@@ @@R E Silverman, «Git Pocket Guide».@@ _
@@O’Reilly Media, 2013.@@ _

@@❉@@ @@S Puisungnoen,@@ @@Git— the simple guide@@ \\http://up1.github.io/git-guide/index.html\\

@@❉@@ @@Git cheatsheet@@ \\http://www.ndpsoftware.com/git-cheatsheet.html\\

~~~

===
%%February 6, 2017;%%
%%revised July 30, 2021%%
===
