
here is a slowly growing summary of Git commands I find helpful, with short explanations to the dear reader.
again, I appreciate anyone to correct my misunderstandings, if any.

Git is a convoluted beast,
and I #try to group actions by their point of departure and arrival.
indeed, interactions #occur between the working tree, the local, and remote repo.
commands@@ ++add++ @@,@@ ++commit++ @@,@@ and ++push++ @@,@@ @@among others, transfer data from the local end to the remote end.
commands@@ ++clone++ @@,@@ ++fetch++ @@,@@ ++pull++ @@,@@ and ++reset++ @@,@@ @@among others, transfer data from the remote end to the local end.

by convention, commands meant to be run in a Bash shell is prefixed with a@@ ++$++ @@.@@
and terms enclosed in ++<>++ are not verbatim.
remember <that Git commands accept the working directory to be either the top directory ({which we assume}) or any of its subdirectory, except ++.git/++, the local repo itself>.
(There are workarounds, but I guess it is safer to follow it.)

Git man pages can be called by, say:

++$ git help fetch++ '

or equivalently:

++$ git fetch --help++ '


=== ##from the tree to the local: add## ===

with@@ ++add++ @@,@@ @@changes in the working tree are &added to the stash.
to stage everything— new, modified, and deleted files— in the working tree:

++$ git add .++ '

to view a list of all tracked files:

++$ git ls-tree -r <branch_name> --name-only++ '

before committing, it is helpful to see a summary of new changes, with:

++$ git status++ '

to show modification in the working tree not added to the index:

++$ git diff++ '

or you can compare the indexed files with the latest commit:

++$ git diff --staged++ '

instead, to compare a specific file in the working tree with the committed version of it:

++$ git diff <commit> <certain_file>++ '

there will be a new page {that summarizes the modification}.
navigation commands are identical to@@ ++less++ @@,@@ @@and similar to Vim.
hit@@ ++j++ @@ @@or ++e++ @@ @@to forward one line,
and@@ ++k++ @@ @@or ++y++ @@,@@ to backward one line.
hit@@ ++f++ @@ @@to forward one window,
and@@ ++b++ @@ @@to backward one window.
hit@@ ++d++ @@ @@to forward one-half window,
and@@ ++u++ @@ @@to backward one-half window.
hit@@ ++q++ @@ @@to quit.

=== ##from the tree to the local: commit## ===

to commit:

++$ git commit++ '

however, a commit message is strongly recommended:

++$ git commit -m "<Commit message>"++ '

a commit message should summarize the new work concisely, within 70 characters.
if you cannot do this, you should probably split your work into more than one commits.
to save space, it is the tradition to use verbs in base form are used, and no period in the end.

you can modify your commit message even after you commit, with

++$ git commit --amend++ '

an editor should open, showing the commit message and the status.
this file is saved as@@ ++.git/COMMIT_EDITMSG++ @@.@@
I find it useful to edit the commit message this way, because I don’t have to backslash- escape special characters.
we may also add more explanatory lines below, separated from the commit message with a blank line.

sometimes we add a tag to single out more significant commits, especially when a commit is released to the public.
To add a tag to the latest commit (even when you have modified the working tree after committing), use

++$ git tag -a "<tag_number>" -m "<Commit_message>"++ '

to simply list all tag names:

++$ git tag++ '

to see <what commit is being pointed to>:

++$ git rev-list -1 "<tag_number>"++ '

a ++git push++ @@ @@don't automatically push a tag, but you have to do:

++$ git push origin "<tag_number>"++ '

the commit log $lists commit hashes, authors, time stamps, and commit messages.
to view the commit log:

++$ git log++ '

to make the log concise and informative:

++$ git log --all --decorate --oneline --graph++ '

pointer ++HEAD++ @@ @@refers to the current commit.
to retrieve its ancestors, two operators could be used.
pointer ++HEAD~2++ @@ @@refers to the eldest parent of the parent of the head.
pointer ++HEAD^3++ @@ @@means its third- to- last eldest parent of the head, and so on.
the two operators may be composed, for instance as ++HEAD^3~2++ @@.@@

=== ##from the local repo to the remote repo: push## ===

to push all consistent commits from the local repo to the remote repo:

++$ git push origin <branch_name>++ '

if option@@ ++-u++ @@is added,@@ @@we set a upstream tracking reference so that we can type only@@ ++git push++ @@or@@ ++git pull++ @@and so on@@.@@

If you have messed up something, and Git is unable to figure out their ancestral relation and thus refuses to push, you may try with the flag `-f` or `--force`:

++$ git push origin <branch_name> -f++ '

This forces every commit in question in the local repo to overwrite its counterpart in the remote repo, and may cause the remote repo to lose data, so think twice before using it.

=== ##from the remote to the local : clone, fetch, pull## ===

to clone everything from the remote repo into a new subdirectory of the current working directory,
(where the repo for the blog is taken for instance)

++$ git clone git@github.com:violapterinblog/violapterinblog.github.io.git++ '

to fetch everything from the remote repo into an existent working tree:

++$ git fetch origin <branch_name>++ '

(Or any remote branch instead of master.) This keeps creates a local copy of a remote branch in the local repo (the `.git` directory) only, while not affecting the working tree, nor the head.
Interestingly, only when we checkout, do we automatically merge the remote branch, having being fetched but not yet in the working tree, with the local branch where the working tree is.

Meanwhile, a `pull` not only fetches all remote branches, as just describe in the above paragraph, but automatically tries to merge all conflicts into the current pointed branch.

++$ git pull origin <branch_name>++ '

(Or any remote branch instead of master.) I feel that it is clearer to fetch and merge explicitly than just to pull, unless the situation is simple enough.

=== ##from the local repo to the working tree: reset, revert## ===

one way of reversing the working tree to a previous commit (together with the index and the head) is `reset`, namely

++$ git reset HEAD~2 --hard++ '

Alternatively, the option `--mixed` (which is the default option) only reverses the index and the head, and `--soft` only reverses the head.

Beside `reset`, `revert` is another way to restore the working tree, but unlike `reset`, it creates a new commit.
For example, with

++$ git revert <commit_pointer>++ '

a new commit which is the previous commit being pointed, is now created.
note that the history is not rewritten in this case.

### Rewriting history

Sometimes we might wish to rewrite the history, so that the last 5 commits (say) become one.
One way to do this is

++$ git reset --hard HEAD~5++ '
++$ git merge --squash HEAD@{1}++ '

The first command resets the head to the commit just before the last 5 commits, and the second command combines these <N> commits.
Here, `HEAD@{1}` is the position of the head just before the previous command.
The command `reset` was already discussed above.
After these commands, commit.

Alternatively (slight difference exists which I do not elaborate here),

++$ git reset --soft HEAD~5++ '

Afterwards, commit.

# Commit those squashed changes.
 The commit message will be helpfully
# prepopulated with the commit messages of all the squashed commits:
git commit


~~~

=== ##references## ===

Git, [Documentation](https://git-scm.com/documentation)

    This is the documentation on the official homepage of Git.
Same material may be found in `man` pages that are included in the Git package itself, to quote the site.

R E Silverman (2013).
Git Pocket Guide.
Sebastopol, CA: O’Reilly Media.

[Git—The Simple Guide](http://up1.github.io/git-guide/index.html)

    A table of for the most common Git commands, and very brief explanations for them.
On the site, there is a downloadable PDF version.

===
%%February 6, 2017%%
===
